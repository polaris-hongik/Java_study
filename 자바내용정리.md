JAVA 내용정리
=============
박찬솔
-------------

# 목차
     1. 프로그래밍 언어 기본요소
     2. 객체지향프로그래밍
     3. 스레드
     4. GUI

* * *
# 0. 자바란?
## JVM(Javs Virtual Machine):자바 가상 머신
     OS로부터 메모리를 할당 받아 그 위에서 Java로 쓰여진 프로그램을 돌림
### 바이트 코드
     가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진표현법
#### 기존 구조: CPU <- 기계어 <- 어셈블리어 <- 컴파일러
     위의 경우 CPU의 종류에 따라 기계어와 어셉블리어가 다름
     따라서 컴파일러 또한 달라져야함
#### 자바 구조: CPU <- JVM <- 바이트 코드 <- 컴파일러
     가상컴퓨터가 설치된 어떠한 하드웨어에서도 동일한 조건으로 프로그램 실행 가능 : 자바의 높은 이식성
     java 파일을 바이트코드로 이루어진 class 파일로 컴파일 한다.
     이때 바이트코드는 인터프리터 언어이기에 자바는 컴파일언어면서 인터프리터언어이다.
    
### JVM구조
#### Class Loader
     Class파일을 로드하고, 사용하지 않으면 메모리에서 삭제
     자바는 동적코드이므로 클래스를 처음 참조할 때 클래스를 로드한다.
#### Execution Engine
     클래스를 두가지 방법을 통해 JVM에서 돌아가게 변환
##### 인터프리터
     명령어 단위로 읽어서 한 줄씩 수행
##### JIT
     일정정도 이상으로 실행되는 코드는 컴파일 하여 캐시에 저장한다.
     인터프리터의 동적이라는 장점과 컴파일 언어의 속도 둘 다 잡음
##### Garbage collector
     프로그램이 동적으로 할당한 메모리 영역 중 필요없어진 영역 해제
#### Runtime Data Area
     OS에서 할당 받은 메모리 공간
##### PC Register
     Thread가 시작될 때마다 생성, 현재 수행 중인 JVM 명령의 주소를 가짐
##### JVM 스택 영역
     임시적으로 할당하고 사용 후 소멸되는 데이터 저장
     변수와 임시데이터, 스레드나 메소드의 정보는 여기 저장됨
     메소드 별로 각각의 그 메소드만을 위한 각각의 프레임이 생성 후 삭제
##### Native method stack
     Java 외의 다른 언어로 작성된 코드를 바이트 코드로 전환하여 저장
     JAVA Native Interface: 바이트 코드로 전환 시켜주는 것
##### Method Area(=Class area=Static area)
     클래스 정보에서 초기화 대상을 정하는 메모리공간
     프로그램의 흐름을 구성하는 메소드의 바이트 코드가 저장됨
###### Runtime Constant Pool
     상수 자료형을 저장하여 참조하고 중복을 막는 역할 수행
###### 올라가는 정보의 종류
     Field Information: 멤버변수의 이름, 데이터 타입, 접근 제어자에 대한 정보
     Method Information: 메소드의 이름, 리턴타입, 매개변수, 접근제어자에 대한 정보
     Type Information: class인지 interface인지 여부 저장 및 Type 속성 전체이름 super class의 전체이름
##### Heap(힙 영역)
     객체를 저장하는 가상 메모리 공간
###### Permanent Generation
     생성된 객체들의 정보인 주소 값이 저장
     Class loader에 의해 load되는 Class, Method 등에 대한 Meta 정보가 저장
     Reflection을 사용하여 동적으로 클래스가 로딩되는 경우 사용
###### New/Young Generation
     Eden: 객체들이 최초로 생성되는 공간
     Survivor 0/1: Eden에서 참조되는 개체들이 저장되는 공간
###### Tenured Generation
     Old: Eden 영역이 가득차면 이곳으로 이동함
    
* * *
# 1. 프로그래밍 언어 기본요소
## 자료형
     여러 종류의 데이터를 식별하는 분류
     기본 자료형과 클래스를 이용하여 선언된 참조자료형이 있음
### 숫자형
     정수형: byte, int, long, longlong
     부동소수점: float, 
     진수표현: 8진수(0), 16진수(0x)
     증감연산 (++,--) 순서에 따른 차이 있음
### 부울(boolean)
     조건문의 판단 기중
### 문자(char)
     char은 2byte-> Unicode를 사용하기 때문
### 문자열(String)
     new String(“”)으로 선언: 새로운 객체 생성
     “”선언: 리터럴 테이블중 같은 항목을 가리킴
     
     equals()는 내용을 비교한다.
     ==는 무엇을 가리키는지 비교한다.
~~~ java
     String a = "a";
     String b = "a";
     String c = new String("a");     
     System.out.println(a==b); //true
     System.out.println(a==c); //false, 가리키는 객체가 서로 다르기 때문
     System.out.println(a.equals(c)); //true
~~~
#### 쓸만한 메소드 
     indexOf(String)
     replaceAll(String, String)
     substring(int,int)
     toUpperCase()/toLowercase()
### StringBuffer
     문자열을 추가 및 변경가능
     append(String)
     insert(int, String)
     
     StringBuffer: 한 객체에서 변경 가능하지만 다소 무겁다.
     String: 변경될 수 없고 변경한다면 새로운 객체를 선언한다.
### 배열: 번호와 번호에 대응하는 데이터들로 이루어진 자료 구조
### 리스트: 같은 값이 한 번 이상 존재할 수 있는 일련의 값이 모여있는 추상적 자료형
     ArrayList<자료형> : 인덱스로 객체를 관리하며, 크기를 동적으로 늘일 수 있다.
     Vector<자료형> : ArrayList와 내부구조는 같지만, 동기화된 메서드로 구성되었다. 따라서 멀티스레드 환경에서 안전하지만 느리다.
     LinkedList<자료형> : 인접 참조를 링크하여 체인으로 관리한다. 특정 인덱스의 객체 제거 시 주변 인덱스의 링크만 바뀐다. -> 좋은 성능
#### 배열 VS 리스트
     배열은 정적인 크기를 가지며 명시적인 자료형
     리스트는 동적인 크기를 가지며 추상적인 자료형 -> 다양한 방법으로 구현 가능
### 맵: 키와 값이 쌍으로 짝지어진 자료구조
     HashMap<키의 자료형, 값의 자료형>
## 제어문
### 조건문
#### if문
     조건연산자: $$ || !
#### case문
     변수 하나를 지정하여 그 값에 따라 실행
     break를 하지 않으면 아래의 모든 조건 실행
### 반복문
#### while문
     조건이 부합하는 한 반복
#### for문
     정해진 횟수만큼 반복
     for문: C언어의 for문
     for each문: 파이썬의 for문

## 입출력
### 콘솔입출력
     콘솔을 통해서 입력 및 출력 가능
#### 입력
     System.in
     jave.util.Scanner: System.in을 가공한 버전
#### 출력
     System.out

### 파일입출력
     파일을 읽고 쓰기 가능 
#### 파일 입력 클래스 정리
     과제를 통해 추가
#### 파일 출력 클래스 정리
     과제를 통해 추가

* * * 
# 2. 클래스
## 객체지향 프로그래밍
### 3요소
#### Encapsulation(캡슐화)
     클래스에 정의된 속성은 숨기고 기능은 공개하는 것
#### Polymorphism(다형성)
     Overriding - 부모 클래스에서 정의되어 있는 내용을 자식클래스에서 재정의하여 사용
     Overloading - 같은 이름의 메소드를 중복해서 만들 수 있음(인자값의 종류는 달라야함)
         인자의 차이에 따라 원하는 기능의 메소드를 정의
#### Polymorphism(상속)
     클래스 사이에 부모와 자식 클래스가 존재할 수 있음
     자식 클래스는 부모 클래스의 속성 및 기능을 물려받는다.

## 클래스
     클래스(class)란 객체를 정의하는 틀 또는 설계도
     객체의 상태를 나타내는 필드(field)와 객체의 행동을 나타내는 메소드(method)
### 필드
     클래스 변수: 모든 인스턴스에서 접근할 수 있음
         Static을 붙여서 선언하는 변수
     인스턴스 변수: 각 인스턴스별로 별도로 관리됨
## 인스턴스
### 인스턴스 변수
     인스턴스에 종속되어 인스턴스 생성시마다 새로운 저장공간을 할당
## 메소드: 클래스 내부에 정의된 함수를 말한다.
     보통 함수를 클래스 외부에 독립적으로 선언 시 함수라고 구분해서 말한다.
### 함수
     매개변수 -> 처리 -> 반환값 으로 동작하는 코드뭉치를 말한다.
     중복되는 코드를 함수로 호출하는 식으로 바꾸면 프로그래밍이 쉬워진다.
### 메소드 변수
     지역변수로서 메소드에서 사용되고 메소드 실행이 종료되면 메모리공간은 반환된다.
## 상속
     기존에 정의되어 있는 클래스의 모든 멤버 변수와 멤버 함수를 물려받아 새로운 클래스를 작성하는 것
     1. 클래스를 재활용 할 수 있음
     2. 중복되어 작성되는 부분을 효율적으로 줄일 수 있음
### IS-A(상속관계의 객체화)
     부모클래스로 데이터형을 선언하고 자식클래스를 생성해서 할당
     부모클래스에서 언급된 변수와 메소드만 호출 할 수 있다.
### HAS-A(포함 관계)
     다른 객체를 받아들여서 그 객체의 기능을 사용
#### 추상 클래스
     어느정도의 규격만 잡아놓은 추상적인 클래스 
## 생성자
~~~ java
public 클래스이름{
    public 클래스이름(매개변수){
    ...
    }
}
~~~
     객체 생성시 가장 먼저 호출이되고 가장 먼저 실행되는 메소드(메소드 아님)
     초기화를 해주는 역할을 한다.
### 디폴트 생성자
     생성자가 없을시 자동으로 아무것도 하지 않는 생성자를 만들어줌
## 인터페이스
     극단적으로 동일한 목적 하에 동일한 기능을 수행하게끔 강제하는 것
### 장점
     1. 개발 시간 단축
     2. 표준화 가능
     3. 관계없는 클래스들에게 관꼐를 맺어 줄 수 있음
     4. 독립적인 프로그래밍 가능
### 구성 요소
#### 상수
     모든 객체가 공유하며, 한번결정된 값은 수정될 수 없음
     static final
#### 추상메소드
     필수적으로 구현되어야 하는 메소드
#### Default메소드
     메소드가 제시되어 있으며 수정될 수 있고, 구현하지 않아도 된다.
#### 정적메소드
     메소드가 제시되어 있으며 수정될 수 없고, 필수적으로 구현되어야 한다.
### 추상클래스와 비교
     인터페이스의 목적은 구현 객체가 같은 동작을 한다는 것을 보장하는것
     추상 클래스의 목적은 동일한 부모를 가지는 클래스를 묶어 기능을 확장시키는 것
### 다형성과 interface 
     인터페이스를 통하여 다형성을 구현하면 원하는 기능에 집중 할 수 있다.(자세한 내용 이해 및 )

